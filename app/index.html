<!doctype html>
<html lang="en">
<head>
	<title>小试正则—交互式的正则表达式教程</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="assets/js/bower/reset-css/reset.css">
	<link rel="stylesheet" href="assets/build/style.css">

	<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,400italic,700">
</head>
<body>
	<header>
		<h1>小试正则</h1>
	</header>

	<div class="main">
		<div class="console">
			<p class="info">在这里输入一些 JavaScript：</p>
			<ul>
				<li class="input-container"><label>
					<span class="prompt">&gt; </span>
					<input class="regex-input"/>
				</label></li>
			</ul>
		</div>

		<div class="tutorial">
			<div class="lesson lesson1">
				<h2>开始使用正则表达式</h2>
				<p>这是一个介绍正则表达式的交互教程，特别是 JavaScript 中的正则表达式。但仍然会教你编写可以在其他语言运行的正则表达式，不过你需要注意它们的不同之处。</p>
				<p>左边是一个 JavaScript 控制台。 使用 <code>setName('Your name')</code> 告诉我们你的名字 （<code>Your name</code> 替换为你的名字）然后开始这个教程吧。</p>
				<p>一些有用的命令：运行 <code>help()</code> 可以查看它们。</p>
			</div>

			<div class="lesson lesson2">
				<h2>正则表达式是什么？</h2>
				<p>正则表达式是一个表示搜索模式的字符串（也称为正则），类似星号用于通配符文件名匹配，但是功能更强大（也因此更复杂）。</p>
				<p>我们将从一个非常基础的例子开始，这样你将掌握正则表达式的语法以及在 JavaScript 中的使用技巧。</p>
				<p><code>bio</code> 变量是一个可能包含你名字的字符串。输入 <code>bio.match(/{{ firstEscaped }}/)</code> 查看它是否包含了你的名字。</p>
			</div>

			<div class="lesson lesson3">
				<p>It does!</p>
				<p>你可以从前面的例子里得知两件事情。第一个是定义正则表达式的语法：简单的将你的表达式包含在一对正斜杠中。</p>

				<pre><code>/your expression/</code></pre>

				<p>如果你将它输入在控制台里，你会看到被返回的正则表达式。</p>
				<p>第二个是你可以使用字符串的 <code>.match()</code> 方法去测试一个表达式。还有一些其他的方法可以调用：例如你可以使用正则表达式的 <code>.exec()</code> 方法去检测字符串。输入 <code>/{{ firstEscaped }}/.exec(bio)</code>。</p>
			</div>

			<div class="lesson lesson4">
				<h2>简单的测试</h2>
				<p><code>.exec()</code> 方法和 <code>.match()</code> 方法做同样的事情，但由正则表达式自身去调用。这是非常有用的。</p>
				<p>另一个你可以使用的方法，可能也是所有方法中最简单的一个，<code>.test()</code> 方法。 它有点类似 <code>.exec()</code>，但返回的是一个布尔值。试试吧！</p>
				<p>有用的提示：你可以使用键盘的向上箭头来返回之前的表达式。</p>
			</div>

			<div class="lesson lesson5">
				<h2>字符串替换</h2>
				<p>最后一个我们会使用的方法是  <code>.replace()</code> ，它是一个字符串替换一些字符为另一些字符的方法。输入以下的命令将你的名字从 <code>bio</code> 变量中隐藏：</p>
				<pre><code>bio.replace(/{{ firstEscaped }}/, '[redacted]')</code></pre>
			</div>

			<div class="lesson lesson6">
				<h2>特殊字符</h2>
				<p>目前为止，我们使用的表达式都不是很有趣，它们都没有包含任何特殊字符。下面的字符在正则表达式中需要转义：</p>
				<pre><code>$()*+.?[^|]</code></pre>
				<p>使用一个反斜杠去转义， 例如 <code>/what\?/</code>。</p>
				<p>写一个正则表达式查看 <code>num</code> 变量是否包含字符串 "3.5"。</p>
			</div>

			<div class="lesson lesson7">
				<h2>点操作符</h2>
				<p>It doesn't! <code>num</code> 等于 123456，所以它没有包含字符串 "3.5"。</p>
				<p>在正则表达式中，点号有一个特殊的含义： 它匹配除了换行符外的任何单一字符 （所以 <code>/a.c/</code> 会匹配 "abc"，"a c"，"a$c" 等等)。 使用 <code>/3.5/</code> （没有转义点号） <em>会</em> 匹配存储在 <code>num</code> 中的字符串， 点号会匹配 "4"。</p>
				<p>试试吧</p>
			</div>

			<div class="lesson lesson8">
				<h2>量词</h2>
				<p>有一些“量词”，你可以用来指明某些字符应该匹配多少次。第一个是问号，在表达式中，它令前面的符号（前一字符或字符组）为可选的。</p>
				<p>表达式 <code>/regexp?/</code> 会匹配 "regex" 和 "regexp"， 因为问号使得 P（但只有P）为可选的。</p>
				<p>编写一个同时匹配 "frontend" 和 "front-end" 的表达式, 然后将其当做参数传递给 <code>answer()</code> 函数（例如 <code>answer(/your expression/)</code>）。</p>
			</div>

			<div class="lesson lesson9">
				<h2>加号</h2>
				<p>接下来的量词，我们将看到的是加号。它的意思是“一个或多个先前标记的”； <code>/Princes+/</code> 会匹配 "Princes"， "Princess"， "Princesssss" 等等。 但它不会匹配 "Prince"。</p>
				<p>现在来编写一个有点复杂的表达式。编写一个正则表达式从 <code>shortStory</code> （你可以通过输入 <code>shortStory</code> 查看变量的内容）变量提取开闭括号之间的内容。提示：你需要前面提到的点操作符。</p>
			</div>

			<div class="lesson lesson10">
				<h2>星号</h2>
				<p>星号和加号有点类似；但不同于加号意味着“一个或多个”，星号的意思是“零个或多个”前面的标记。<code>/Princes*/</code>，除了会匹配由 <code>/Princes+/</code> 匹配到的例子，同时也会匹配 "Prince"。</p>
				<p>重复上一个例子，但是用星号代替加号。从 <code>shortStory</code> 变量提取括号之间所有的内容，即使有可能内容为空。</p>
			</div>

			<div class="lesson lesson11">
				<h2>有限重复</h2>
				<p>There is one final quantifier that you can use which allows you to limit repetition. The syntax is <code>{min,max}</code> which min is the minimum number of repetitions and max the maximum. For example, <code>/a{3,5}/</code> would match "aaa", "aaaa" and "aaaaa", but nothing else.</p>
				<p>Write an expression to match the text between an opening and closing parenthesis in the <code>bracketNumbers</code> variable—but only if the contents are between 5 and 8 characters long.</p>
			</div>

			<div class="lesson lesson12">
				<h2>More limited repetition</h2>
				<p>In addition to specifying a range of repetitions, you can specify an exact number of repetitions using <code>{n}</code> where n is the number of repetitions. The expression <code>a{6}</code>, for example, will match exactly six repetitions of the letter a.</p>
				<p>You can leave out the maximum when using curly parentheses, which will match at least <em>minimum</em> values, with no maximum limit. For example, <code>/a{5,}/</code> will match five or more of the letter a.</p>
				<p>Pass the <code>answer()</code> function the equivalent of <code>/a?b+c*/</code>, but without using any of these characters: <code>?*+</code></p>
			</div>

			<div class="lesson lesson13">
				<h2>Flags—the case insensitive flag</h2>
				<p>Flags are used to modify the behaviour of a regular expression, and they are specified after the expression (eg <code>/your expression/ig</code>). Each flag is represented by a letter, and JavaScript supports four of—two of which will be covered in this tutorial. The <code>i</code> flag makes the expression case insensitive—while without the flag <code>/a/</code> would match "a" and not "A", <code>/a/i</code> would match both "a" and "A".</p>
				<p>Run <code>/CAT/i.exec('Category')</code> to see the <code>i</code> flag in action.</p>
			</div>

			<div class="lesson lesson14">
				<h2>Flags—The global flag</h2>
				<p>The second commonly used flag is the global flag, represented by the letter <code>g</code>. While <code>/a/</code> only matches the first a in the string given to it, <code>/a/g</code> would match every single letter a.</p>
				<p>Write a regular expression to replace every instance of the letter "a" in the <code>shortStory</code> variable with the letter "e".</p>
				<p>Remember that strings have a <code>.replace(expr, replace)</code> method that you can use for replacements.</p>
			</div>

			<div class="lesson lesson15">
				<h2>Character classes</h2>
				<p>Character classes allow you to specify a set or range of characters to be matched. <code>/[aeiou]/</code> matches any vowel, <code>/[a-m]/</code> matches any letter in the first half of the alphabet, and <code>/[aeiou0-9]/</code> matches any vowel or digit.</p>
				<p>Note that inside a character class, you don't need to escape dots and they will be matched literally. If you want a literal hyphen, however, you will need to escape it.</p>
				<p>We're given a string which should contain a username consisting of 5 to 12 letters (uppercase or lowercase) or hyphens. Write some code that will <strong>return true</strong> if the <code>username</code> variable contains a valid username.</p>
			</div>

			<div class="lesson lesson16">
				<h2>Negated character classes</h2>
				<p>A <em>negated</em> character class will match any character that <em>isn't</em> in the character class. You negate a character class by putting a caret character (^) at the beginning of the class. For example, <code>/[^a-m]/</code> will match "z" and "$", but it will not match "c".</p>
				<p>It's important to note the distinction between "not [a-m]" and "something that isn't [a-m]". <code>/c[^a]t/</code> will match "cut", but it won't match "cat" and it won't match "ct"—this is important.</p>
				<p>The username can now contain any character that isn't a space (but still has to be between 5 and 12 characters long). Write a new expression to validate the <code>username</code> variable.</p>
			</div>

			<div class="lesson lesson17">
				<h2>Character types</h2>
				<p>Character types can be used as shorthand for common character classes. There are six character types: <code>\d</code> matches decimal digits (0-9), <code>\s</code> matches whitespace characters, and <code>\w</code> matches word characters (letters—including international characters—numbers and the underscore).</p>
				<p>The other three character types can be found by capitalising the first three character types, which will negate their effect; <code>\S</code> while match any non-whitespace character, for example.</p>
				<p>Write an expression to match a word, followed by a space, followed by a string of digits. Test the <code>charTypeTest</code> variable with it: don't use any literal characters.</p>
			</div>

			<div class="lesson lesson18">
				<h2>Positions</h2>
				<p>If you want to make sure that an expression starts or ends at a certain place in a word—for example, if you want to make sure that a string starts with a capital letter—then you can use an anchor. The dollar sign matches the end of a string, and the caret sign (^) matches the beginning. <code>/^cat$/</code> will match "cat" and nothing else (while just <code>/cat/</code> will match anything with "cat" in.</p>
				<p>Write an expression to test whether the <code>possibleUrl</code> variable starts with "http://" or "https://" and then doesn't contain any spaces all the way to the end.</p>
				<p>Hint: Use a question mark for the protocol, and then a negated character class for the rest. You'll need both anchors.</p>
			</div>

			<div class="lesson lesson19">
				<h2>Capturing groups</h2>
				<p>You can use parentheses to create groups, which can group multiple tokens together or store a result for later reference:</p>
				<pre><code>/"(.+)"/</code></pre>
				<p>That's an example of a capturing group, meaning that the part of the matched string within the parentheses is saved to a later point in the array returned by <code>.match()</code> or <code>.exec()</code>.</p>

				<p>Take our previous example where we grabbed the data between two parentheses using an expression like <code>/\(.{5,8}\)/.exec(shorterStory)</code>. Try running that again, and then wrapping "<code>.{5,8}</code>" in parentheses and trying again.</p>
			</div>

			<div class="lesson lesson20">
				<h2>Non-capturing groups</h2>
				<p>You can see that the array is now two items long: the first item is the entire match, and the second is only the data that the capturing group matched.</p>
				<p>There is another type of group called a non-capturing group. This type of group, which has a slightly different syntax, doesn't store the value to an array. If you don't need to refer back to the group, you should prefer a non-capturing group: it keeps the return array cleaner. Turn the group in the previous expression into a non-capturing group by inserting "<code>?:</code>" into the beginning of the group before the dot.</p>
			</div>

			<div class="lesson lesson21">
				<h2>Quantifiers</h2>
				<p>It's almost as if we don't have a group.</p>
				<p>The main use of non-capturing groups is to apply a quantifier to a number of tokens. The following would match "I ate" and "{{ firstName }} and I ate", but nothing else:</p>
				<pre><code>/^(?:{{ firstEscaped }} and )?I ate$/</code></pre>
				<p>Write an expression which matches "ha" repeated two or more times (eg, "haha" or "hahahahaha"), and pass it the <code>answer()</code> function.</p>
				<p>Hint: your expression shouldn't match "hahah". Use anchors to ensure that it doesn't.</p>
			</div>

			<div class="lesson lesson22">
				<h2>The pipe symbol</h2>
				<p>You can specify an "or" using the pipe symbol (|). The following will match "The dog ate" and "The cat ate":</p>
				<pre><code>/The (dog|cat) ate/</code></pre>
				<p>We could also use a non-capturing group, but in this case we wanted to access the result. You can use as many pipes in one group as you want. Make the previous expression match "The rabbit ate" (currently stored in the <code>rabbit</code> variable), in addition to what it used to match.</p>
			</div>

			<div class="lesson lesson23">
				<h2>Backreferences</h2>
				<p>You can reference the value of a previous capturing group later within the same expression. You simply write a backslash followed by the number of the capturing group (the index of where it will be in the returned array). For example, the following will match "The cat ate with the other cat" and "The dog ate with the other dog", but not "the cat ate with the other dog" (after all, that would just be absurd):</p>
				<pre><code>/The (dog|cat) ate with the other \1/</code></pre>
				<p>Write an expression to match the same two words in a row (eg "hello hello world"): give the expression to the <code>answer()</code> function as in previous examples.</p>
			</div>

			<div class="lesson lesson24">
				<h2>The RegExp object</h2>
				<p>In addition to the literal operator (the slashes), JavaScript provides a RegExp constructor which allows you to specify your desired expression as a string. This is useful for putting variable in expressions. It works like this:</p>
				<pre><code>// Same as /regexp?/ig
new RegExp('regexp?', 'ig');</code></pre>
				<p>The username contains a variable (still). The <code>userData</code> variable contains user data: print it to the console to see the format of the data. Use the <code>username</code> variable to extract the word associated with our user. Please put your entire answer on one line so that it can be validated.</p>
			</div>

			<div class="lesson lesson25">
				<h2>Advanced replacement</h2>
				<p>We've seen two ways in which capturing groups can have their captured value used later on: the first was the returned array, and the second was in a backreference. You can also access them from the second argument of the string <code>.replace()</code> method:</p>
				<pre><code>var text = '*italic text*';
var replace = '&lt;em&gt;$1&lt;/em&gt;';
text.replace(/\*([^*]+)\*/, replace);</code></pre>
				<p>Write some similar code, but to turn the value of the <code>boldText</code> variable into a <code>&lt;strong&gt;</code> element.</p>
			</div>

			<div class="lesson lesson26">
				<h2>Lazy vs greedy matching</h2>
				<p>By default, pattern matching in JavaScript is "greedy", which means that it matches as much as it possibly can:</p>
				<pre><code>'"Hi", "Hello"'.match(/".+"/)</code></pre>
				<p>That will return <code>"Hi", "Hello"</code>, as it matches the two outermost quotes. Lazy pattern matching is the opposite of greedy pattern matching, and will match as little as possible—so in this case, only <code>"Hi"</code>.</p>
				<p>Lazy pattern matching can be achieved by putting a question mark after the quantifier—try it out with the example above.</p>
			</div>

			<div class="lesson lesson27">
				<h2>Assertions</h2>
				<p>An assertion is a pattern that should be matched, but will not be stored: so instead of "match a and then b", we have "match a that is followed by b, but don't match b". There are two types of assertion supported in JavaScript, positive lookaheads and negative lookaheads. Lookaheads just means looking forwards; JavaScript doesn't support lookbehinds.</p>
				<p>A positive lookahead means that we want to look ahead for a match. To look for an a followed by a b, we could use <code>/a(?=b)/</code>.</p>
				<p>Use an assertion to extract "6+3" from the <code>partialSums</code> variable. Don't use any literal digits, use <code>\d</code>.</p>
			</div>

			<div class="lesson lesson28">
				<h2>Negative assertions</h2>
				<p>Assertions can also be negative, to say that you want to match something that <em>isn't</em> followed by something. Note that unlike a character class, this can match something that isn't that—if you say "a that isn't followed by b", the a can be at the end of the string.</p>
				<p>The syntax for a negative assertion is similar to that of a positive assertion, but you replace the equals sign with an exclamation mark: for example, <code>/a(?!b)/</code> would find a letter a that isn't followed by a letter b.</p>
				<p>Use a positive assertion followed by a negative assertion to extract "3+3" from the <code>partialSums</code> variable.</p>
			</div>

			<div class="lesson lesson29">
				<h2>You have finished!</h2>
				<p>Congratulations, {{ firstName }}, on finishing Try Regex. You've now briefly covered most areas of regular expressions in JavaScript, and you should be able to write regex for most situations.</p>
				<p>For further reading, try out the following links:</p>

				<ul>
					<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">Mozilla Developer Network: Regular Expressions</a></li>
					<li><a href="http://tech.pro/tutorial/1214/javascript-regular-expression-enlightenment">JavaScript Regular Expression Enlightenment</a> by Cody Lindley</li>
					<li><a href="http://refcardz.dzone.com/refcardz/regular-expressions">DZone: The Essential Regular Expressions Cheat Sheet</a> by Callum Macrae</li>
					<li><a href="http://leaverou.github.io/regexplained/">RegExp playground</a> by Lea Verou</li>
					<li><a href="http://www.regular-expressions.info/tutorial.html">regular-expressions.info</a> for a general, non-language-specific guide.</li>
				</ul>
			</div>
		</div>
	</div>

	<footer>
		<p>Site by <a href="http://macr.ae/">Callum Macrae</a>. Translated by <a href="http://etsblog.com/">e_t</a>. <small>Copyright &copy; 2014</small></p>
	</footer>

	<a class="gh-ribbon" href="https://github.com/ethrea1/tryregex"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://github-camo.global.ssl.fastly.net/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>

	<!-- This div is always hidden; it's for cloning from -->
	<div class="hidden-storage">
		<ul>
			<li class="prompt-completed">
				<span class="prompt">&gt; </span>
				<code></code>
			</li>
			<li class="prompt-result"><code></code></li>
		</ul>
	</div>

	<script data-main="assets/js/app" src="assets/js/bower/requirejs/require.js"></script>

	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-47497633-2', 'tryregex.com');
		ga('send', 'pageview');
	</script>
</body>
</html>
